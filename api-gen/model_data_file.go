/*
Apache Iceberg REST Catalog API

Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package icebergclient

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the DataFile type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &DataFile{}

// DataFile struct for DataFile
type DataFile struct {
	ContentFile
	Content string `json:"content"`
	// Map of column id to total count, including null and NaN
	ColumnSizes *CountMap `json:"column-sizes,omitempty"`
	// Map of column id to null value count
	ValueCounts *CountMap `json:"value-counts,omitempty"`
	// Map of column id to null value count
	NullValueCounts *CountMap `json:"null-value-counts,omitempty"`
	// Map of column id to number of NaN values in the column
	NanValueCounts *CountMap `json:"nan-value-counts,omitempty"`
	// Map of column id to lower bound primitive type values
	LowerBounds *ValueMap `json:"lower-bounds,omitempty"`
	// Map of column id to upper bound primitive type values
	UpperBounds *ValueMap `json:"upper-bounds,omitempty"`
}

type _DataFile DataFile

// NewDataFile instantiates a new DataFile object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewDataFile(content string, filePath string, fileFormat FileFormat, specId int32, partition []PrimitiveTypeValue, fileSizeInBytes int64, recordCount int64) *DataFile {
	this := DataFile{}
	this.Content = content
	this.FilePath = filePath
	this.FileFormat = fileFormat
	this.SpecId = specId
	this.Partition = partition
	this.FileSizeInBytes = fileSizeInBytes
	this.RecordCount = recordCount
	return &this
}

// NewDataFileWithDefaults instantiates a new DataFile object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewDataFileWithDefaults() *DataFile {
	this := DataFile{}
	return &this
}

// GetContent returns the Content field value
func (o *DataFile) GetContent() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Content
}

// GetContentOk returns a tuple with the Content field value
// and a boolean to check if the value has been set.
func (o *DataFile) GetContentOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Content, true
}

// SetContent sets field value
func (o *DataFile) SetContent(v string) {
	o.Content = v
}

// GetColumnSizes returns the ColumnSizes field value if set, zero value otherwise.
func (o *DataFile) GetColumnSizes() CountMap {
	if o == nil || IsNil(o.ColumnSizes) {
		var ret CountMap
		return ret
	}
	return *o.ColumnSizes
}

// GetColumnSizesOk returns a tuple with the ColumnSizes field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *DataFile) GetColumnSizesOk() (*CountMap, bool) {
	if o == nil || IsNil(o.ColumnSizes) {
		return nil, false
	}
	return o.ColumnSizes, true
}

// HasColumnSizes returns a boolean if a field has been set.
func (o *DataFile) HasColumnSizes() bool {
	if o != nil && !IsNil(o.ColumnSizes) {
		return true
	}

	return false
}

// SetColumnSizes gets a reference to the given CountMap and assigns it to the ColumnSizes field.
func (o *DataFile) SetColumnSizes(v CountMap) {
	o.ColumnSizes = &v
}

// GetValueCounts returns the ValueCounts field value if set, zero value otherwise.
func (o *DataFile) GetValueCounts() CountMap {
	if o == nil || IsNil(o.ValueCounts) {
		var ret CountMap
		return ret
	}
	return *o.ValueCounts
}

// GetValueCountsOk returns a tuple with the ValueCounts field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *DataFile) GetValueCountsOk() (*CountMap, bool) {
	if o == nil || IsNil(o.ValueCounts) {
		return nil, false
	}
	return o.ValueCounts, true
}

// HasValueCounts returns a boolean if a field has been set.
func (o *DataFile) HasValueCounts() bool {
	if o != nil && !IsNil(o.ValueCounts) {
		return true
	}

	return false
}

// SetValueCounts gets a reference to the given CountMap and assigns it to the ValueCounts field.
func (o *DataFile) SetValueCounts(v CountMap) {
	o.ValueCounts = &v
}

// GetNullValueCounts returns the NullValueCounts field value if set, zero value otherwise.
func (o *DataFile) GetNullValueCounts() CountMap {
	if o == nil || IsNil(o.NullValueCounts) {
		var ret CountMap
		return ret
	}
	return *o.NullValueCounts
}

// GetNullValueCountsOk returns a tuple with the NullValueCounts field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *DataFile) GetNullValueCountsOk() (*CountMap, bool) {
	if o == nil || IsNil(o.NullValueCounts) {
		return nil, false
	}
	return o.NullValueCounts, true
}

// HasNullValueCounts returns a boolean if a field has been set.
func (o *DataFile) HasNullValueCounts() bool {
	if o != nil && !IsNil(o.NullValueCounts) {
		return true
	}

	return false
}

// SetNullValueCounts gets a reference to the given CountMap and assigns it to the NullValueCounts field.
func (o *DataFile) SetNullValueCounts(v CountMap) {
	o.NullValueCounts = &v
}

// GetNanValueCounts returns the NanValueCounts field value if set, zero value otherwise.
func (o *DataFile) GetNanValueCounts() CountMap {
	if o == nil || IsNil(o.NanValueCounts) {
		var ret CountMap
		return ret
	}
	return *o.NanValueCounts
}

// GetNanValueCountsOk returns a tuple with the NanValueCounts field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *DataFile) GetNanValueCountsOk() (*CountMap, bool) {
	if o == nil || IsNil(o.NanValueCounts) {
		return nil, false
	}
	return o.NanValueCounts, true
}

// HasNanValueCounts returns a boolean if a field has been set.
func (o *DataFile) HasNanValueCounts() bool {
	if o != nil && !IsNil(o.NanValueCounts) {
		return true
	}

	return false
}

// SetNanValueCounts gets a reference to the given CountMap and assigns it to the NanValueCounts field.
func (o *DataFile) SetNanValueCounts(v CountMap) {
	o.NanValueCounts = &v
}

// GetLowerBounds returns the LowerBounds field value if set, zero value otherwise.
func (o *DataFile) GetLowerBounds() ValueMap {
	if o == nil || IsNil(o.LowerBounds) {
		var ret ValueMap
		return ret
	}
	return *o.LowerBounds
}

// GetLowerBoundsOk returns a tuple with the LowerBounds field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *DataFile) GetLowerBoundsOk() (*ValueMap, bool) {
	if o == nil || IsNil(o.LowerBounds) {
		return nil, false
	}
	return o.LowerBounds, true
}

// HasLowerBounds returns a boolean if a field has been set.
func (o *DataFile) HasLowerBounds() bool {
	if o != nil && !IsNil(o.LowerBounds) {
		return true
	}

	return false
}

// SetLowerBounds gets a reference to the given ValueMap and assigns it to the LowerBounds field.
func (o *DataFile) SetLowerBounds(v ValueMap) {
	o.LowerBounds = &v
}

// GetUpperBounds returns the UpperBounds field value if set, zero value otherwise.
func (o *DataFile) GetUpperBounds() ValueMap {
	if o == nil || IsNil(o.UpperBounds) {
		var ret ValueMap
		return ret
	}
	return *o.UpperBounds
}

// GetUpperBoundsOk returns a tuple with the UpperBounds field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *DataFile) GetUpperBoundsOk() (*ValueMap, bool) {
	if o == nil || IsNil(o.UpperBounds) {
		return nil, false
	}
	return o.UpperBounds, true
}

// HasUpperBounds returns a boolean if a field has been set.
func (o *DataFile) HasUpperBounds() bool {
	if o != nil && !IsNil(o.UpperBounds) {
		return true
	}

	return false
}

// SetUpperBounds gets a reference to the given ValueMap and assigns it to the UpperBounds field.
func (o *DataFile) SetUpperBounds(v ValueMap) {
	o.UpperBounds = &v
}

func (o DataFile) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o DataFile) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	serializedContentFile, errContentFile := json.Marshal(o.ContentFile)
	if errContentFile != nil {
		return map[string]interface{}{}, errContentFile
	}
	errContentFile = json.Unmarshal([]byte(serializedContentFile), &toSerialize)
	if errContentFile != nil {
		return map[string]interface{}{}, errContentFile
	}
	toSerialize["content"] = o.Content
	if !IsNil(o.ColumnSizes) {
		toSerialize["column-sizes"] = o.ColumnSizes
	}
	if !IsNil(o.ValueCounts) {
		toSerialize["value-counts"] = o.ValueCounts
	}
	if !IsNil(o.NullValueCounts) {
		toSerialize["null-value-counts"] = o.NullValueCounts
	}
	if !IsNil(o.NanValueCounts) {
		toSerialize["nan-value-counts"] = o.NanValueCounts
	}
	if !IsNil(o.LowerBounds) {
		toSerialize["lower-bounds"] = o.LowerBounds
	}
	if !IsNil(o.UpperBounds) {
		toSerialize["upper-bounds"] = o.UpperBounds
	}
	return toSerialize, nil
}

func (o *DataFile) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"content",
		"file-path",
		"file-format",
		"spec-id",
		"partition",
		"file-size-in-bytes",
		"record-count",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varDataFile := _DataFile{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varDataFile)

	if err != nil {
		return err
	}

	*o = DataFile(varDataFile)

	return err
}

type NullableDataFile struct {
	value *DataFile
	isSet bool
}

func (v NullableDataFile) Get() *DataFile {
	return v.value
}

func (v *NullableDataFile) Set(val *DataFile) {
	v.value = val
	v.isSet = true
}

func (v NullableDataFile) IsSet() bool {
	return v.isSet
}

func (v *NullableDataFile) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDataFile(val *DataFile) *NullableDataFile {
	return &NullableDataFile{value: val, isSet: true}
}

func (v NullableDataFile) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDataFile) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


